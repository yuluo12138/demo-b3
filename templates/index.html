{% extends "base.html" %}

{% block title %}数据展示系统 - 实时搜索{% endblock %}
{% block page_title %}数据接收概览与搜索{% endblock %}
{% block nav_links %}
    {# 这里的导航链接与base.html中的默认值相同，您可以选择移除此block以使用base.html的默认链接 #}
    <a href="{{ url_for('index') }}">首页</a>
    <a href="{{ url_for('map_page') }}">地图</a> {# 新增地图页面链接 #}
{% endblock %}

{% block content %}
    <div class="search-controls">
        <div>
            <label for="searchQuery">内容搜索</label>
            <input type="text" id="searchQuery" placeholder="输入 ID、定位时间、经纬度、自定义数据、原始POST数据等...">
        </div>
        <div>
            <label>接收时间范围</label>
            <div class="input-group">
                <input type="datetime-local" id="startDate"> <!-- 修改为 datetime-local -->
                <input type="datetime-local" id="endDate">   <!-- 修改为 datetime-local -->
            </div>
        </div>
    </div>

    <div class="summary-stats">
        <div class="summary-item">
            <div class="value" id="displayedIdCount">0</div>
            <div class="label">显示卡号数量</div>
        </div>
        <div class="summary-item">
            <div class="value" id="displayedMessageCount">0</div>
            <div class="label">显示消息总数</div>
        </div>
    </div>

    <div id="jsError" class="no-data-message error" style="display: none;">
        前端脚本发生错误，请查看浏览器控制台 (F12) 获取详情。
    </div>
    <div id="noSearchResults" class="no-data-message" style="display: none;">
        未找到匹配的数据。请尝试调整搜索条件。
    </div>
    <div id="initialNoData" class="no-data-message" style="display: block;">
        目前没有接收到任何数据。等待设备上报数据或刷新页面。
    </div>

    <div id="messagesContainer">
        <!-- 消息卡片将在这里通过 JavaScript 渲染 -->
    </div>

    <script>
        console.log('--- Frontend Debugging Start: Script Loaded (index.html) ---');
        document.getElementById('jsError').style.display = 'none';

        // 接收所有 ID 的所有消息 (已在后端格式化)
        // 结构: { "ID1": [formatted_msg1, formatted_msg2, ...], "ID2": [...] }
        const allMessagesGroupedById = {{ all_messages_grouped_by_id | tojson }};
        const sortedIdNumbersArray = {{ sorted_id_numbers_js_arr | tojson }};

        console.log('Received allMessagesGroupedById (JavaScript object from Flask): ', allMessagesGroupedById);
        console.log('Received sortedIdNumbersArray:', sortedIdNumbersArray);

        if (Object.keys(allMessagesGroupedById).length > 0) {
            document.getElementById('initialNoData').style.display = 'none';
        }
        
        const messagesContainer = document.getElementById('messagesContainer');
        const searchQueryInput = document.getElementById('searchQuery');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const noSearchResultsDiv = document.getElementById('noSearchResults');
        const initialNoDataDiv = document.getElementById('initialNoData');
        const displayedIdCountSpan = document.getElementById('displayedIdCount');
        const displayedMessageCountSpan = document.getElementById('displayedMessageCount');

        // 辅助函数：判断消息是否匹配搜索查询
        function messageMatchesQuery(msg, query) {
            if (!query) return true; // 无查询时，所有消息都匹配

            const lowerCaseQuery = query.toLowerCase();

            // 检查 ID Number
            if (String(msg['IdNumber']).toLowerCase().includes(lowerCaseQuery)) return true;
            // 检查 MessageId
            if (String(msg['MessageId']).toLowerCase().includes(lowerCaseQuery)) return true;
            // 检查接收时间
            if (String(msg['接收时间']).toLowerCase().includes(lowerCaseQuery)) return true;
            // 检查数据标识
            if (String(msg['数据标识']).toLowerCase().includes(lowerCaseQuery)) return true;
            // 检查解析状态文本
            if (msg['解析状态'] && String(msg['解析状态'].text).toLowerCase().includes(lowerCaseQuery)) return true;
            // 检查表格列内容
            // 注意: TABLE_COLUMNS 是在 base.html 的 script 标签中定义的，因此在这里是可用的。
            for (const col of TABLE_COLUMNS) { 
                const value = String(msg[col.key]);
                if (value.toLowerCase().includes(lowerCaseQuery)) return true;
            }
            // 检查原始POST数据
            if (msg['raw_post_data_json'] && String(msg['raw_post_data_json']).toLowerCase().includes(lowerCaseQuery)) return true;

            return false;
        }

        // 辅助函数：判断消息是否匹配日期时间范围
        function messageMatchesDateRange(msg, startDateStr, endDateStr) {
            if (!startDateStr && !endDateStr) return true; // 无日期时间范围时，所有消息都匹配

            const receiveTime = msg['接收时间']; // 例如: "2023-10-27T10:30:00"
            if (!receiveTime) return false;

            try {
                const messageDate = new Date(receiveTime); // 直接解析 ISO 格式
                if (isNaN(messageDate.getTime())) {
                    console.warn("Invalid message receive time format:", receiveTime);
                    return false;
                }

                // input type="datetime-local" 产出的格式也是 ISO 格式 (YYYY-MM-DDTHH:mm:ss)
                const start = startDateStr ? new Date(startDateStr) : null;
                const end = endDateStr ? new Date(endDateStr) : null;
                
                if (start && isNaN(start.getTime())) { console.warn("Invalid start date string:", startDateStr); start = null; }
                if (end && isNaN(end.getTime())) { console.warn("Invalid end date string:", endDateStr); end = null; }

                if (start && messageDate < start) {
                    return false;
                }
                if (end && messageDate > end) {
                    return false;
                }
                return true;
            } catch (e) {
                console.error("日期时间解析错误:", e, "Receive Time:", receiveTime);
                return false;
            }
        }

        function renderMessages() {
            console.log('--- renderMessages called (index.html) ---');
            const query = searchQueryInput.value.trim(); 
            const lowerCaseQuery = query.toLowerCase();
            const startDateStr = startDateInput.value;
            const endDateStr = endDateInput.value;
            
            // 判断是否处于搜索模式 (只要有搜索框内容或日期时间范围，即视为搜索模式)
            const isSearching = !!query || !!startDateStr || !!endDateStr; 
            
            let totalFilteredMessagesCount = 0; // 实际显示的卡片数量 (搜索模式下为匹配数，非搜索模式下为所有历史总数)
            let displayedIdNumbers = new Set(); 
            let htmlOutput = '';

            // 如果没有数据，显示无数据或无搜索结果信息
            if (Object.keys(allMessagesGroupedById).length === 0) {
                messagesContainer.innerHTML = '';
                displayedIdCountSpan.textContent = 0;
                displayedMessageCountSpan.textContent = 0;
                if (!isSearching) { // 没有搜索条件，且没有数据
                    initialNoDataDiv.style.display = 'block';
                    noSearchResultsDiv.style.display = 'none';
                } else { // 有搜索条件，但没有数据 (例如，用户在空数据时尝试搜索)
                    initialNoDataDiv.style.display = 'none';
                    noSearchResultsDiv.style.display = 'block';
                }
                return;
            } else {
                initialNoDataDiv.style.display = 'none'; // 有数据时，隐藏“目前没有接收到任何数据”
            }

            // 遍历所有 ID (使用后端提供的已排序的 ID 数组)
            for (const idNumber of sortedIdNumbersArray) { 
                const messagesForId = allMessagesGroupedById[idNumber];
                if (!messagesForId || messagesForId.length === 0) continue;

                let messagesHtmlForCurrentIdGroup = ''; // 用于当前 ID 分组内的消息卡片
                let idGroupHasMatchedMessages = false;
                let matchedMessagesCountForCurrentId = 0; // 【新】用于记录当前ID匹配搜索的消息数量

                if (isSearching) {
                    // 搜索模式：遍历该 ID 下的所有历史消息
                    for (const msg of messagesForId) {
                        if (messageMatchesDateRange(msg, startDateStr, endDateStr) && messageMatchesQuery(msg, lowerCaseQuery)) {
                            messagesHtmlForCurrentIdGroup += createMessageCardHtml(
                                idNumber, 
                                msg, 
                                query,          // 传递原始query用于高亮
                                true,           // 搜索模式下，卡片默认展开
                                false           // isHistoryView: false (主页)
                            );
                            idGroupHasMatchedMessages = true;
                            totalFilteredMessagesCount++; // 搜索模式下，只统计匹配的消息
                            matchedMessagesCountForCurrentId++; // 【新】累加当前ID匹配的消息数量
                        }
                    }
                } else {
                    // 非搜索模式：只显示最新一条消息，但计算所有历史消息总数
                    const latestMsg = messagesForId[0]; // 消息已按时间倒序排列，第一个就是最新
                    if (latestMsg) {
                        messagesHtmlForCurrentIdGroup += createMessageCardHtml(
                            idNumber, 
                            latestMsg, 
                            query,          // 即使没有搜索，也要传递query给highlightText，它会处理空query
                            false,          // 非搜索模式下，卡片默认折叠
                            false           // isHistoryView: false (主页)
                        );
                        idGroupHasMatchedMessages = true;
                    }
                    // 在非搜索模式下，无论是否显示最新一条，都将当前ID的所有历史消息数量累加到总数中
                    totalFilteredMessagesCount += messagesForId.length; 
                    // 【新】非搜索模式下，当前ID的消息数量就是所有历史消息数量
                    matchedMessagesCountForCurrentId = messagesForId.length; 
                }

                // 如果该 ID 下有匹配的消息（或非搜索模式下的最新消息），则添加 ID 分组
                if (idGroupHasMatchedMessages) {
                    displayedIdNumbers.add(idNumber);

                    // 【修改】ID 分组的头部，现在根据是否搜索来决定显示匹配数量还是总历史数量
                    const countToDisplayInHeader = isSearching ? matchedMessagesCountForCurrentId : messagesForId.length;

                    // ID 分组的折叠图标，搜索模式下默认展开（箭头朝下），非搜索模式下默认折叠（箭头朝左）
                    const idGroupToggleIconClass = `id-group-toggle-icon ${isSearching ? '' : 'rotated'}`;
                    const idGroupHeader = `
                        <div class="id-group-header">
                            <div>ID: <span class="id-text">${highlightText(idNumber, query)}</span> (共 ${countToDisplayInHeader} 条)</div>
                            <span class="${idGroupToggleIconClass}">▼</span>
                        </div>
                    `;
                    // ID 分组的内容区域，根据是否搜索来决定默认是展开还是折叠
                    const idGroupContentClass = `id-group-content ${isSearching ? '' : 'collapsed'}`;

                    htmlOutput += `
                        <div class="id-group">
                            ${idGroupHeader}
                            <div class="${idGroupContentClass}">
                                ${messagesHtmlForCurrentIdGroup}
                            </div>
                        </div>
                    `;
                }
            }

            messagesContainer.innerHTML = htmlOutput;

            // 只有在搜索模式且没有找到结果时，才显示"未找到匹配数据"
            if (totalFilteredMessagesCount === 0 && isSearching) { 
                noSearchResultsDiv.style.display = 'block';
            } else {
                noSearchResultsDiv.style.display = 'none';
                // 确保在内容渲染后绑定事件
                // bindCardToggleEvents 和 bindIdGroupToggleEvents 在 base.html 的 script 中，这里直接调用即可
                bindCardToggleEvents();    // 绑定消息卡片的折叠事件
                bindIdGroupToggleEvents(); // 绑定 ID 分组的折叠事件
            }

            displayedIdCountSpan.textContent = displayedIdNumbers.size;
            displayedMessageCountSpan.textContent = totalFilteredMessagesCount;
            console.log(`--- renderMessages finished --- Displayed IDs: ${displayedIdNumbers.size}, Total Messages: ${totalFilteredMessagesCount}`);
        }

        // 绑定搜索和日期时间过滤器的事件
        searchQueryInput.addEventListener('input', renderMessages);
        startDateInput.addEventListener('change', renderMessages);
        endDateInput.addEventListener('change', renderMessages);

        // 页面加载完成后立即渲染一次消息
        document.addEventListener('DOMContentLoaded', renderMessages);
        
    </script>
{% endblock %}
